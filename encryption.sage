from typing import Tuple
from Crypto.Random import get_random_bytes
from Crypto.Signature.pss import MGF1
from Crypto.Hash import SHA256
from Crypto.Util.strxor import strxor
from Crypto.Util.Padding import pad, unpad

from sage.all import crt, random_prime, log, Integers, gcd, is_prime, ZZ


BIT_LEN_PRIME = 1024  # 2048
BYTE_LEN_RANDOMNESS = 128
REDUNDANCY = 10


def keyGen():
    p = 1
    while p % 4 != 3:
        p = random_prime(
            2**BIT_LEN_PRIME, proof=False, lbound=2 ** (BIT_LEN_PRIME - 1)
        )  # proof = False for performances
    q = 1
    while q % 4 != 3:
        q = random_prime(
            2**BIT_LEN_PRIME, proof=False, lbound=2 ** (BIT_LEN_PRIME - 1)
        )  # proof = False for performances
    return (p, q, p * q)


def mgf(seed, length):
    # This function is correct and you don't need to look at it
    # It generates a mask of given length using the seed as input
    return MGF1(seed, length, SHA256)


def encrypt(m: bytes, n: int) -> int:
    BYTE_LEN_MESSAGE_PART = int(log(n, 2)) // 8 - BYTE_LEN_RANDOMNESS
    if len(m) > BYTE_LEN_MESSAGE_PART - REDUNDANCY - 1:
        raise Exception(
            "Message too long. Maximum "
            + str(BYTE_LEN_MESSAGE_PART - REDUNDANCY - 1)
            + " bytes"
        )
    m = pad(m, BYTE_LEN_MESSAGE_PART, style="iso7816")
    r = get_random_bytes(BYTE_LEN_RANDOMNESS)
    h = mgf(r, BYTE_LEN_MESSAGE_PART)
    m = strxor(m, h) + r
    return (int.from_bytes(m, "little") ** 2) % n


def decrypt(c: int, p: int, q: int) -> bytes:
    n = p * q
    BYTE_LEN_MESSAGE_PART = int(log(n, 2)) // 8 - BYTE_LEN_RANDOMNESS

    P = Integers(p)
    Q = Integers(q)
    (p_c, q_c) = (P(c), Q(c))
    (p_roots, q_roots) = (p_c.sqrt(all=True), q_c.sqrt(all=True))

    roots: list[bytes] = []
    for pr in p_roots:
        for qr in q_roots:
            root = crt([pr.lift(), qr.lift()], [p, q])
            roots.append(root.to_bytes((root.nbits() + 7) // 8, "little"))

    # try each root until unpad doesn't throw
    for root in roots:
        try:
            r = root[BYTE_LEN_MESSAGE_PART:]
            m = root[:BYTE_LEN_MESSAGE_PART]
            h = mgf(r, BYTE_LEN_MESSAGE_PART)
            m = strxor(m, h)
            m = unpad(m, BYTE_LEN_MESSAGE_PART, style="iso7816")

            if len(m) > BYTE_LEN_MESSAGE_PART - REDUNDANCY - 1:
                raise Exception("invalid length")
            return m
        except Exception:
            continue
    raise Exception("does not work :(")


def find_correct_root(n: int, message: bytes, roots: list[int]) -> int:
    """
    Attempt to find the root used for the known message

    Args:
        n (int): The modulus used.
        message (bytes): The known message.
        roots (list[int]): A list of candidate roots to try.

    Returns:
        int: The root that matched with the known message

    Raises:
        Exception: If no valid root yields a correctly‐formatted message.
    """
    BYTE_LEN_MESSAGE_PART = int(log(n, 2)) // 8 - BYTE_LEN_RANDOMNESS
    for root in roots:
        try:
            tmp = root.to_bytes((root.bit_length() + 7) // 8, "little")
            r = tmp[BYTE_LEN_MESSAGE_PART:]
            m = tmp[:BYTE_LEN_MESSAGE_PART]
            h = mgf(r, BYTE_LEN_MESSAGE_PART)
            m = strxor(m, h)
            m = unpad(m, BYTE_LEN_MESSAGE_PART, style="iso7816")

            if len(m) > BYTE_LEN_MESSAGE_PART - REDUNDANCY - 1:
                continue

            if m == message:
                return root
        except Exception:
            continue

    raise Exception("couldn't find a valid root")


def find_diff_roots(n: int, roots: list[int]) -> Tuple[int, int]:
    roots = list(set(roots))
    for i in range(len(roots)):
        for j in range(i + 1, len(roots)):
            if (roots[i] + roots[j]) % n != 0:
                return (roots[i], roots[j])
    raise Exception("Only found roots which are inverse of each other")


def find_pq(n: int, roots: list[int], verify: bool = True):
    """
    Find p and q using the following formula
    x1 != -x2 (mod n)
    x1 equiv a mod p, b mod p
    x2 equiv a mod p, -b mod p

    """
    # ensure there are no duplicates
    (x1, x2) = find_diff_roots(n, roots)
    p = gcd(x1 - x2, n)
    q = n / p
    if verify:
        if not is_prime(ZZ(p)) or not is_prime(ZZ(q)):
            raise Exception("found none prime p or q")
    return (p, q)


def main():
    (p, q, n) = keyGen()
    m = b"Your heart's been aching but you're too shy to say it."
    c = encrypt(m, n)
    res = decrypt(c, p, q)
    if m == res:
        print("success")
        print(res)
    else:
        print(f"found : {res}")


def main_break():
    n = 15224501632483840743864161085970356975498869981090878499746618717295161176551026639470648649023090247579390266188723822368295340786531545133485378278983061503080008535976820385686949351077093099997077922789136590750224535107133167704773360578246126309966130807544634201034719092010659530170703799443298011388196939719629779105190360388503090267049102718094391964476742332128301025273180513623496364494030737921882565984978167276366001443912916355135910749312242093025962936110806556912086235867048525555409663088321451366674805338687723269459826865996328495397040287068677621415269899989944844982920607325373683244937
    m = b"Your heart's been aching but you're too shy to say it."
    c = 1356251225512430560591235171568825209583152611861273860561770651665580437089761801766380987176854453757615669976870148435388222382913500442716598585042550818055947869930883172196294671292659390602815173859666028398310886030150073984519079190456959698531818496829365989744281358454632215754800932822989972008904243277788329432466593571509604273562915277900990820536790211140997168463040151320534321715844137918008615002980905975581188220320371209006819490958788533696432120702965584577488286020706786744967133139732491417109283951470442557537418151442585225582157652963823105467876244383531293204317577024531518789938
    roots = [
        98415412002447206087259528219776056339499434103140558107932079889384280133746838264548067680136937815450225382795830795633245166499736808329928394576194602752372250290600858635471662549747272804480244818325118270394739931912926954952372019381530565596912597257538268697860641812952362335951592047365863816124086514670517642903086952934047726656861562928515506353410388373414014967676473549378591730194449300159576060444122550879266362215219466356899911310123920903709777905138376120749550816020934766106500779318047347047261145182269788984227579292040589692646253646916652924151879831896823767336821416105854161943,
        12699453794151532111287219376362511845363208764439459895271581143132847728837837486524694489299495077707487096583001343459419842631503453518312407410393389321051655343291829326165116473934804740248965608386361405711723394926388597282305177352359486320568588074559148652258976312116925533413635123398649581857174707266647485130552682201023541970440083256656400802900035425208361692877765449326022967020523939282702588262685951024490398501390350153524749451680850134711833214076340633194765597690964264994710235393355193516661181591478566379541656357222608337734685076263067802185794686663922915616705514816865794827163,
        2525047838332308632576941709607845130135661216651418604475037574162313447713189152945954159723595169871903169605722478908875498155028091615172970868589672182028353192684991059521832877142288359748112314402775185038501140180744570422468183225886639989397542732985485548775742779893733996757068676044648429531022232452982293974637678187479548296609019461437991161576706906919939332395415064297473397473506798639179977722292216251875602942522566201611161297631391958314129722034465923717320638176084260560699427694966257850013623747209156889918170508773720157662355210805609819229475213326021929366215092508507888417774,
        15126086220481393537776901557750580919159370546987737941638686637405776896417279801206100581342953309763940040805927991572662095620031808325155449884406866900327636285686219527051477688527345827192597677970811472479829795175220240749820988558864595744369218210287095932336858450197707167834752207395932147572072853204959261462287273435569042540392241155165876458123331943754887010305504040074117772763836288621722989924534044725486735081697696888779010838002118172122253158205668180791336685051027590789303162309003404019627544193505453480475599286704287905704394033421760968491118020158048021215583785909267829082994,
    ]

    root = find_correct_root(n, m, roots)

    # Find a pair of roots where ri + rj mod n != 0
    (p, q) = find_pq(n, roots)

    if decrypt(c, p, q) != m:
        raise Exception("Invalid p and q found")

    chall = 4393877302650311808760348842121446309084622700069390353052046258177263905917685768889076940277313220797024378877446493003728224359657582684849663461261442610425343235947894945545473183568482822873620924041079588087607036175128578654048427812111853372674329153000165290975856310984269112999733559143381253428008420830658511059615444348042380513889839760850621741225120778458099606443315924391486924991903916645864466166567644314437533125938672269193087647781177682718064890174394269228455318808197029907198052661253822158706578380787033838652937192403844724243497405630077867656676190147655991746880420709661229784905
    print(decrypt(chall, p, q))


if __name__ == "__main__":
    # main()
    main_break()
